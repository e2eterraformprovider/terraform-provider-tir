---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "tir_modelEndpoint Resource - tir"
subcategory: ""
description: |-
  
---

# tir_modelEndpoint (Resource)

IR provides two methods for deploying containers that serve model API endpoints for AI inference services:

Deploy Using Pre-built Containers (Provided by TIR)

Before launching a service with TIR's pre-built containers, you need to create a TIR Model and upload the necessary model files. These containers are configured to automatically download model files from an EOS (E2E Object Storage) Bucket and start the API server. Once the endpoint is ready, you can make synchronous requests to the endpoint for inference. 
Deploy using your own container

You can launch an inference service using your own Docker image, either public or private. Once the endpoint is ready, you can make synchronous requests for inference. Optionally, you can attach a TIR model to automate the download of model files from an EOS bucket to the container. 

## Example Usage

```hcl

 resource "tir_modelEndpoint" "name:string" {
  # stop_inference = "start"

  name                     = "name"
  sku_name                 = "C3.2"
  sku_type                 = "hourly"
  committed_instance_policy = ""
  committed_days           = 0
  model_path               = ""
  framework                = "PYTORCH"
  model_id                 = tir_modelRepository.name.id // if you want to import model from your model repo
   model_load_integration_id = tir_integration.name.id // if you want to download model from hugging face
  cluster_type             = "tir-cluster" or "private-cluster" 
  storage_type             = "disk"
  disk_path                = "/mnt/models"
  sfs_path                 = "/shared/.cache"
  sfs_id                   = "1"
  image_pull_policy        = "Always"
  is_auto_scale_enabled    = false
  replica                  = 1
  committed_replicas      = 0
  
  auto_scale_policy {
    # min_replicas = 1
    # max_replicas = 5
    # rules {
        # Define rules as you needed.
     }
    # stability_period = 300
    rules {

    }
  }

  detailed_info {
    # commands          = "[\"jatin\",\"rahul\"]"
    # args              = ""
    # hugging_face_id   = "BAAI/Aquila-7B"
    server_version = "v0.9.0"
    tokenizer         = ""
    world_size        = 1
    error_log         = true
    info_log          = true
    warning_log       = true
    log_verbose_level = 1
    model_serve_type  = ""
    engine_args =  {
      # Define engine_args as you needed.
      block_size                        = ""
      chat_template                     = ""
      data_type                         = "auto"
      disable_custom_all_reduce         = tostring("false")
      disable_log_requests              = tostring("false")
      disable_log_stats                 = tostring("false")
      disable_sliding_window            = tostring("false")
      distributed_executor_backend      = ""
      enable_auto_tool_choice           = tostring("false")
      enable_chunked_prefill            = tostring("false")
      enable_lora                       = tostring("false")
      enable_lora_bias                  = tostring("false")
      enable_prefix_caching             = tostring("false")
      enforce_eager                     = tostring("false")
      fully_sharded_loras               = tostring("false")
      gpu_memory_utilization            = tostring("0.9")
      guided_decoding_backend           = "xgrammar"
      kv_cache_data_type                = "auto"
      load_format                       = "auto"
      long_lora_scaling_factors         = ""
      lora_data_type                    = "auto"
      lora_extra_vocab_size             = tostring("256")
      max_cpu_loras                     = ""
      max_log_len                       = ""
      max_logprobs                      = tostring("20")
      max_lora_rank                     = tostring("16")
      max_loras                         = tostring("1")
      max_model_length                  = ""
      max_num_batched_tokens           = tostring("5")
      max_num_seqs                      =  tostring("256")
      max_parallel_loading_workers      = ""
      max_seq_len_to_capture           = tostring("8192")
      model_loader_extra_config         = ""
      ngram_prompt_lookup_max          = ""
      ngram_prompt_lookup_min          = ""
      num_gpu_blocks_override           = ""
      num_lookahead_slots               = tostring("0")
      num_speculative_tokens            = ""
      preemption_mode                   = ""
      quantization                      = ""
      rope_scaling                      = ""
      rope_theta                        = ""
      scheduler_delay_factor            = tostring("0")
      seed                              = tostring("0") 
      skip_tokenizer_init               = tostring("false")
      spec_decoding_acceptance_method   = "rejection_sampler"
      speculative_disable_by_batch_size = ""
      speculative_draft_tensor_parallel_size = ""
      speculative_max_model_len         = ""
      speculative_model                 = ""
      swap_space                        = tostring("4")
      tokenizer                         = ""
      tokenizer_mode                    = "auto"
      tokenizer_pool_extra_config       = ""
      tokenizer_pool_size               = tostring("0")
      tokenizer_pool_type               = "ray"
      tokenizer_revision                = ""
      tool_call_parser                  = ""
      typical_acceptance_sampler_posterior_alpha = tostring("5")
      typical_acceptance_sampler_posterior_threshold = tostring("0.09")
    }

  }

  is_readiness_probe_enabled  = false
  is_liveness_probe_enabled   = false

  readiness_probe {
    # Define readiness as you need.
  }

  liveness_probe {
   # Define liveness probe as you need.
  }

  resource_details {
    disk_size = 100
    mount_path = ""
    env_variables {
      key   = "abc"
      value = "abc"
      required = true
      disabled = {
        key   = true
        value = false
      }
    }
    env_variables {
      key   = "HF_HOMsE"
      value = "ENV_VALsUE"
      required = true
      disabled = {
        key   = true
        value = false
      }
    }
  }

  public_ip = "no"
  container_type = "public"
  private_cloud_id = "private_cloud_123"
  custom_sku = {
    "sku_name" = 1
  }
    team_id = <team_id : string>
    project_id = <project_id:string>
    active_iam = <active_iam:string>
    location = "Delhi"
    currency = "INR"
}

```



<!-- schema generated by tfplugindocs -->
## Schema

### Required

- `active_iam` (String) The IAM (Identity and Access Management) role associated with the resource.
- `cluster_type` (String) The type of cluster the resource is deployed on.
- `container_type` (String) The type of container used for the resource (e.g., public, private).
- `currency` (String) The currency used for billing the resource.
- `framework` (String) The framework used for the model. This could be TensorFlow, PyTorch, etc.
- `location` (String) The location or region where the resource is deployed.
- `name` (String) The name of the resource. This is a required field and must be unique within the project.
- `project_id` (String) The ID of the project where the resource is deployed.
- `sku_name` (String) The SKU (Stock Keeping Unit) name for the resource. This defines the type of resource being deployed.
- `sku_type` (String) The SKU type for the resource. This defines the category or classification of the SKU.
- `storage_type` (String) The type of storage used for the resource.
- `team_id` (String) The ID of the team that owns the resource.

### Optional

- `auto_scale_policy` (Block List) The policy for auto-scaling the resource. This includes min/max replicas and scaling rules. (see [below for nested schema](#nestedblock--auto_scale_policy))
- `committed_days` (Number) The number of days the instance is committed for. This is used for billing and resource allocation.
- `committed_instance_policy` (String) The policy for committed instances. This defines how committed instances are managed and billed.
- `committed_replicas` (Number) The number of replicas that are committed for the resource.
- `custom_sku` (Map of Number) A map of custom SKU configurations for the private cloud .
- `dataset_id` (String) The ID of the dataset associated with the resource.
- `dataset_path` (String) The path to the dataset used by the resource.
- `detailed_info` (Block List) Detailed information about the resource, including commands, args, and logging settings. (see [below for nested schema](#nestedblock--detailed_info))
- `disk_path` (String) The path where the disk is mounted. This is used to specify the location for model storage.
- `image_pull_policy` (String) The policy for pulling container images. Options are 'Always' or 'IfNotPresent'.
- `is_auto_scale_enabled` (Boolean) Indicates whether auto-scaling is enabled for the resource.
- `is_liveness_probe_enabled` (Boolean) Enable or disable the liveness probe for the resource.
- `is_readiness_probe_enabled` (Boolean) Enable or disable the readiness probe for the resource.
- `liveness_probe` (Block List) Configuration for the liveness probe. (see [below for nested schema](#nestedblock--liveness_probe))
- `metric_port` (Boolean) Indicates whether a metric port is exposed for the resource.
- `model_id` (String) The unique identifier for the model. This is used to reference the model in the system.
- `model_load_integration_id` (String) The integration ID used for loading the model. This is typically used for custom model loading workflows.
- `model_path` (String) The path to the model file or directory. This is used to specify the location of the model to be deployed.
- `private_cloud_id` (String) The ID of the private cloud where the resource is deployed.
- `public_ip` (String) Indicates whether a public IP address is assigned to the resource.
- `readiness_probe` (Block List) Configuration for the readiness probe. (see [below for nested schema](#nestedblock--readiness_probe))
- `replica` (Number) The number of replicas to deploy for the resource.
- `resource_details` (Block List) Additional details about the resource, such as disk size, mount path, and environment variables. (see [below for nested schema](#nestedblock--resource_details))
- `server_options` (String) Specifies the server options for the resource. This is typically used for server types like TRITON, PYTORCH, NEMO, and TENSOR RT.
- `service_port` (Boolean) Indicates whether a service port is exposed for the resource.
- `sfs_id` (String) The ID of the shared file storage. This is used to reference the shared storage resource.
- `sfs_path` (String) The path for shared file storage. This is used for caching and shared resources.
- `stop_inference` (String) Indicates whether to stop or start inference for the resource. Default is 'start'.

### Read-Only

- `container_name` (String) The name of the container associated with the resource. This is computed automatically.
- `created_at` (String) The timestamp when the resource was created. This is computed automatically.
- `id` (String) The ID of this resource.
- `status` (String) The current status of the resource. This is computed automatically.

<a id="nestedblock--auto_scale_policy"></a>
### Nested Schema for `auto_scale_policy`

Optional:

- `max_replicas` (Number) The maximum number of replicas to scale up to during auto-scaling.
- `min_replicas` (Number) The minimum number of replicas to maintain during auto-scaling.
- `rules` (Block List) The rules for auto-scaling based on metrics and conditions. (see [below for nested schema](#nestedblock--auto_scale_policy--rules))
- `stability_period` (Number) The period (in seconds) to wait after scaling before scaling again.

<a id="nestedblock--auto_scale_policy--rules"></a>
### Nested Schema for `auto_scale_policy.rules`

Optional:

- `condition_type` (String) The type of condition to apply for scaling.
- `custom_metric_name` (String) The name of a custom metric to use for scaling.
- `granularity` (Number) The granularity of the metric data collection.
- `metric` (String) The metric to monitor for auto-scaling
- `value` (Number) The threshold value for the metric to trigger scaling.
- `watch_period` (Number) The period (in seconds) to watch the metric before scaling.
- `window` (Number) The time window (in seconds) for evaluating the metric.



<a id="nestedblock--detailed_info"></a>
### Nested Schema for `detailed_info`

Optional:

- `args` (String) Arguments to pass to the commands when the resource is deployed.
- `commands` (String) Commands to execute when the resource is deployed.
- `engine_args` (Map of String) Additional engine-specific arguments for the model.
- `error_log` (Boolean) Enable or disable error logging.
- `hugging_face_id` (String) The Hugging Face model ID associated with the resource.
- `info_log` (Boolean) Enable or disable info logging.
- `log_verbose_level` (Number) The verbosity level for logging.
- `model_serve_type` (String) The type of model serving (e.g., real-time, batch).
- `server_version` (String) The version of the server being used.
- `tokenizer` (String) The tokenizer to use for the model.
- `warning_log` (Boolean) Enable or disable warning logging.
- `world_size` (Number) The world size for distributed training or inference.


<a id="nestedblock--liveness_probe"></a>
### Nested Schema for `liveness_probe`

Optional:

- `commands` (String) Commands to execute for the liveness probe.
- `failure_threshold` (Number) The number of failed probes before the resource is marked as not live.
- `grpc_service` (String) The gRPC service to check for the liveness probe.
- `initial_delay_seconds` (Number) The initial delay (in seconds) before the liveness probe starts.
- `path` (String) The path to check for the liveness probe.
- `period_seconds` (Number) The period (in seconds) between liveness probe checks.
- `port` (Number) The port to use for the liveness probe.
- `protocol` (String) The protocol to use for the liveness probe (e.g., http, tcp).
- `success_threshold` (Number) The number of successful probes required to mark the resource as live.
- `timeout_seconds` (Number) The timeout (in seconds) for the liveness probe.


<a id="nestedblock--readiness_probe"></a>
### Nested Schema for `readiness_probe`

Optional:

- `commands` (String) Commands to execute for the readiness probe.
- `failure_threshold` (Number) The number of failed probes before the resource is marked as not ready.
- `grpc_service` (String) The gRPC service to check for the readiness probe.
- `initial_delay_seconds` (Number) The initial delay (in seconds) before the readiness probe starts.
- `path` (String) The path to check for the readiness probe.
- `period_seconds` (Number) The period (in seconds) between readiness probe checks.
- `port` (Number) The port to use for the readiness probe.
- `protocol` (String) The protocol to use for the readiness probe (e.g., http, tcp).
- `success_threshold` (Number) The number of successful probes required to mark the resource as ready.
- `timeout_seconds` (Number) The timeout (in seconds) for the readiness probe.


<a id="nestedblock--resource_details"></a>
### Nested Schema for `resource_details`

Optional:

- `disk_size` (Number) The size of the disk (in GB) allocated for the resource.
- `env_variables` (Block List) Environment variables to be set for the resource. (see [below for nested schema](#nestedblock--resource_details--env_variables))
- `mount_path` (String) The path where the disk is mounted.

<a id="nestedblock--resource_details--env_variables"></a>
### Nested Schema for `resource_details.env_variables`

Optional:

- `disabled` (Map of Boolean) A map of disabled environment variables.
- `key` (String) The key for the environment variable.
- `required` (Boolean) Indicates whether the environment variable is required.
- `value` (String) The value for the environment variable.
